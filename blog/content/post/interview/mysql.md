---
title: Mysql索引总结
date: 2020-05-18
tags: [Mysql]
categories: [手艺]
---


<!-- more -->
# Mysql 索引
1. MySQL索引数据结构底层为什么不用二叉树
    > 顺序查找时, 单边增长的列还是全表查询, 没有一丝增长
2. MySQL索引数据结构底层为什么不用红黑树(二叉平衡树)
    > 数据越多, 树的高度越大. 即数据量越大查询越慢.
3. MySQL索引数据结构底层为什么使用B+Tree
    1. 首先B Tree与B+Tree的区别是, B Tree节点上的data数据, 挪移到最后层的叶子节点上. 其次, B+Tree比B Tree叶子节点上多了双向指针, 存储了磁盘地址, 方便做范围查询. 
    2. 每次索引查询时, 都会将每层的索引load到内存中进行二分比对, 直到找到data数据, 这样就导致BTree相对于B+Tree会很重, B+Tree找到相应的索引后才会去拉取数据
    3. 每一页的索引都是做了排序
    4. 树高控制在3层高度, 每一层叫一页(innodb_page_size), 默认为16KB(大概可以放1170多个元素)
4. 为什么不使用红黑树
    > 相对于红黑树, BTree可以压缩树的高度.
5. innodb索引的结构有哪些? 分别都有什么优劣
    1. 有两种, 一种是BTree, 另一种是hash
    2. Hash速度快, 尤其是等值或者”IN”的时候, 但是有hash冲突的和不支持范围查询的问题;
6. 为什么推荐使用Innodb, 为什么推荐使用整形自增主键
    1. innodb与my在存储结构上的不同决定的, innodb可以按照索引直接查找到数据, My按照索引只能查找到数据的磁盘文件地址, 还要到另一种表中查找数据, 性能上有浪费
    2. 在索引排序规则下, 使用自增会很方便的在后面新增节点, 相反, 如果不使用自增, 在已经排序完很多节点的情况下, 再插入中间的节点, 会造成索引排序引擎非常大的压力, 又将已经排序好的节点做重新的分裂, 也有可能在根节点做变动.
7. MY的主键索引和非主键索引是一样的类型, Innodb的主键索引和非主键索引是不一样的类型, 非主键索引存储的data, 是这张表的聚集索引(一般是主键索引), 这么做是为了一致性和节约空间, 二级索引都是非聚集索引, innodb每张表只有一张聚集索引
8. 聚合索引, 使用的是左列前缀, 按照索引建立的前后顺序来做索引排序

# Mysql Explain
1. 关联查询时要使用主键关联
